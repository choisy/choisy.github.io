<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R receipes</title>
    <link>/</link>
    <description>Recent content on R receipes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 May 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Parallel computation</title>
      <link>/2018/05/30/parallel-computation/</link>
      <pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/05/30/parallel-computation/</guid>
      <description>Parallel version of replicate with parallel Loading the package:
&amp;gt; library(parallel) of which we’ll use the 6 following functions:
 detectCores which detects the number of CPU cores; makeCluster which creates a cluster of a given number of cores; clusterEvalQ which evaluates a literal expression on each cluster node. It is a parallel version of evalq. clusterExport which assigns the values on the master R process of the variables named in its named list argument to variables of the same names in the global environment (aka workspace) of each node; parSapply parallel version of sapply.</description>
    </item>
    
    <item>
      <title>System language</title>
      <link>/2018/05/14/system-language/</link>
      <pubDate>Mon, 14 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/05/14/system-language/</guid>
      <description>You can change the language in which R is talking to the user from the definition of the LANG environment variable:
&amp;gt; Sys.getenv(&amp;quot;LANG&amp;quot;) [1] &amp;quot;fr_FR.UTF-8&amp;quot; &amp;gt; log(-3) Warning in log(-3): production de NaN [1] NaN Changing to English:
&amp;gt; Sys.setenv(LANG = &amp;quot;en_US.UTF-8&amp;quot;) &amp;gt; log(-3) Warning in log(-3): NaNs produced [1] NaN and back to French:
&amp;gt; Sys.setenv(LANG = &amp;quot;fr_FR.UTF-8&amp;quot;) &amp;gt; log(-3) Warning in log(-3): production de NaN [1] NaN Or, alternatively:</description>
    </item>
    
    <item>
      <title>Spatial buffers</title>
      <link>/2018/01/22/spatial-buffers/</link>
      <pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/01/22/spatial-buffers/</guid>
      <description>Packages needed Install these packages if they are not already installed on your system, then load them:
&amp;gt; library(sp) # plot, points, spsample &amp;gt; library(purrr) # map2 &amp;gt; library(dplyr) # %&amp;gt;%, mutate &amp;gt; library(rgeos) # gIntersection &amp;gt; library(raster) # plot, buffer &amp;gt; library(geosphere) # areaPolygon We can compute statistics in buffer zones around specific points. For that we need spatial data in raster format. These data can be qualitative (e.g. land cover) or quantitative (e.</description>
    </item>
    
    <item>
      <title>Confidence intervals</title>
      <link>/2018/01/09/confidence-intervals/</link>
      <pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/01/09/confidence-intervals/</guid>
      <description>Simulating fake data:
&amp;gt; x &amp;lt;- 10 * runif(10) &amp;gt; y &amp;lt;- rnorm(10, mean = 2 + 3 * x, 3) Visualizing:
&amp;gt; plot(y ~ x, col = &amp;quot;blue&amp;quot;, pch = 19) Estimating a linear model:
&amp;gt; model &amp;lt;- lm(y ~ x) Calculating and plotting 95 % confidence interval based on simulations:
&amp;gt; xr &amp;lt;- 100 &amp;gt; nb &amp;lt;- 1000 &amp;gt; ci &amp;lt;- .95 &amp;gt; eps &amp;lt;- (1 - ci) / 2 &amp;gt; xs &amp;lt;- seq(min(x), max(x), length = xr) &amp;gt; coef_val &amp;lt;- MASS::mvrnorm(nb, coef(model), vcov(model)) &amp;gt; ys &amp;lt;- t(coef_val %*% rbind(1, xs)) &amp;gt; predconf &amp;lt;- t(apply(ys, 1, quantile, c(eps, 1 - eps))) Let’s plot all this:</description>
    </item>
    
    <item>
      <title>Palettes of colors</title>
      <link>/2018/01/08/palettes-of-colors/</link>
      <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/01/08/palettes-of-colors/</guid>
      <description>A great function to generate palettes of colors is colorRampPalette from the grDevices package. This function takes a set of colors as argument and returns a function similar to grDevices::heat.colors and others that generates a palette of n contiguous colors, n being an argument of this function. The generation of the palette of colors is done by interpolation (spline or linear) and a good starting points for interpolation are the “sequential” and “diverging” palettes generated by RColorBrewer::brewer.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Thu, 05 May 2016 21:48:51 -0700</pubDate>
      
      <guid>/about/</guid>
      <description>This is a collection of R recipes.</description>
    </item>
    
  </channel>
</rss>