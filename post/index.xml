<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on R receipes</title>
    <link>/post/</link>
    <description>Recent content in Posts on R receipes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 May 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>System language</title>
      <link>/2018/05/14/system-language/</link>
      <pubDate>Mon, 14 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/05/14/system-language/</guid>
      <description>You can change the language in which R is talking to the user from the definition of the LANG environment variable:
&amp;gt; Sys.getenv(&amp;quot;LANG&amp;quot;) [1] &amp;quot;fr_FR.UTF-8&amp;quot; &amp;gt; log(-3) Warning in log(-3): production de NaN [1] NaN Changing to English:
&amp;gt; Sys.setenv(LANG = &amp;quot;en_US.UTF-8&amp;quot;) &amp;gt; log(-3) Warning in log(-3): NaNs produced [1] NaN and back to French:
&amp;gt; Sys.setenv(LANG = &amp;quot;fr_FR.UTF-8&amp;quot;) &amp;gt; log(-3) Warning in log(-3): production de NaN [1] NaN Or, alternatively:</description>
    </item>
    
    <item>
      <title>Spatial buffers</title>
      <link>/2018/01/22/spatial-buffers/</link>
      <pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/01/22/spatial-buffers/</guid>
      <description>Packages needed Install these packages if they are not already installed on your system, then load them:
&amp;gt; library(sp) # plot, points, spsample &amp;gt; library(purrr) # map2 &amp;gt; library(dplyr) # %&amp;gt;%, mutate &amp;gt; library(rgeos) # gIntersection &amp;gt; library(raster) # plot, buffer &amp;gt; library(geosphere) # areaPolygon We can compute statistics in buffer zones around specific points. For that we need spatial data in raster format. These data can be qualitative (e.g. land cover) or quantitative (e.</description>
    </item>
    
    <item>
      <title>Confidence intervals</title>
      <link>/2018/01/09/confidence-intervals/</link>
      <pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/01/09/confidence-intervals/</guid>
      <description>Simulating fake data:
&amp;gt; x &amp;lt;- 10 * runif(10) &amp;gt; y &amp;lt;- rnorm(10, mean = 2 + 3 * x, 3) Visualizing:
&amp;gt; plot(y ~ x, col = &amp;quot;blue&amp;quot;, pch = 19) Estimating a linear model:
&amp;gt; model &amp;lt;- lm(y ~ x) Calculating and plotting 95 % confidence interval based on simulations:
&amp;gt; xr &amp;lt;- 100 &amp;gt; nb &amp;lt;- 1000 &amp;gt; ci &amp;lt;- .95 &amp;gt; eps &amp;lt;- (1 - ci) / 2 &amp;gt; xs &amp;lt;- seq(min(x), max(x), length = xr) &amp;gt; coef_val &amp;lt;- MASS::mvrnorm(nb, coef(model), vcov(model)) &amp;gt; ys &amp;lt;- t(coef_val %*% rbind(1, xs)) &amp;gt; predconf &amp;lt;- t(apply(ys, 1, quantile, c(eps, 1 - eps))) Let’s plot all this:</description>
    </item>
    
    <item>
      <title>Palettes of colors</title>
      <link>/2018/01/08/palettes-of-colors/</link>
      <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/01/08/palettes-of-colors/</guid>
      <description>A great function to generate palettes of colors is colorRampPalette from the grDevices package. This function takes a set of colors as argument and returns a function similar to grDevices::heat.colors and others that generates a palette of n contiguous colors, n being an argument of this function. The generation of the palette of colors is done by interpolation (spline or linear) and a good starting points for interpolation are the “sequential” and “diverging” palettes generated by RColorBrewer::brewer.</description>
    </item>
    
  </channel>
</rss>