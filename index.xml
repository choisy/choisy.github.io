<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R recipes</title>
    <link>https://choisy.github.io/</link>
    <description>Recent content on R recipes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 28 Dec 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://choisy.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Statistical temporal downscaling</title>
      <link>https://choisy.github.io/2018/12/28/statistical-temporal-downscaling/</link>
      <pubDate>Fri, 28 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/2018/12/28/statistical-temporal-downscaling/</guid>
      <description>Downscaling is a procedure that consists in infering high-resolution information from low-resolution data. This can be performed either in time or, more commonly, in space. Methodologically, it can be performed statistically (statistical downscaling) based on observed relationships between the variables of our data or mechanistically (often called dynamical downscaling), using a mechanistical model of the process generating the data. Such techniques are widely used for example in meteorology and climatology in order to derive local-scale weather and climate from Global Climate Models (GCM) data that have a typical resolution of 50 x 50 km.</description>
    </item>
    
    <item>
      <title>Computing weather variables by province</title>
      <link>https://choisy.github.io/2018/11/08/computing-weather-variables-by-province/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/2018/11/08/computing-weather-variables-by-province/</guid>
      <description>Weather variables such as temperature, humidity, rainfall, etc… are collected from climatic stations. These data are thus available from points in space whereas we often need them to be representative of administrative units (e.g. provinces) which are polygons. A strategy to transform points data into polygons data is to perform interpolation of points data onto a grid and then aggregation of grid data into polygons, as illustrated on the figure below:</description>
    </item>
    
    <item>
      <title>Computing population centers</title>
      <link>https://choisy.github.io/2018/10/29/computing-population-centers/</link>
      <pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/2018/10/29/computing-population-centers/</guid>
      <description>In demographics, the centre of population (or population center, or population centroid) of a region is a geographical point that describes a centrepoint of the region’s population. See here for more detail. The figure below shows for example the change of the location of the population center of the USA from 1790 to 2010:

 In this post we show how we can use population density raster data from the WorldPop project to calculate population centers of given polygons such as those provided by the GADM project.</description>
    </item>
    
    <item>
      <title>Downloading files from Github or Dropbox</title>
      <link>https://choisy.github.io/2018/09/10/downloading-files-from-github-or-dropbox/</link>
      <pubDate>Mon, 10 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/2018/09/10/downloading-files-from-github-or-dropbox/</guid>
      <description>There are functions in R that work on URL, such as download.file or even read.table (plus many others, including some from dedicated packages such as RCurl). One may thus think that (s)he can just go on a Github or Dropbox webpage, copy the URL of the file their are interested in and paste it directly into R. It’s almost that, except for a little tweak. Indeed the URL that you would copy this way is the URL to the file display on the webpage.</description>
    </item>
    
    <item>
      <title>Big data packages</title>
      <link>https://choisy.github.io/2018/05/31/big-data-packages/</link>
      <pubDate>Thu, 31 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/2018/05/31/big-data-packages/</guid>
      <description>When you create an R data package, it may happen that the data is too big to be hosted on CRAN that has a package size limit of 5 MB or even on Github that has a repository size limit of 1 GB and a file size limit of 100 MB. Here I show how to build such a package in a way that leaves the data on another server and then lets the user download the data when (s)he needs it for the first time.</description>
    </item>
    
    <item>
      <title>Parallel computation</title>
      <link>https://choisy.github.io/2018/05/30/parallel-computation/</link>
      <pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/2018/05/30/parallel-computation/</guid>
      <description>Parallel version of replicate with parallel Loading the package:
&amp;gt; library(parallel) of which we’ll use the 6 following functions:
 detectCores which detects the number of CPU cores; makeCluster which creates a cluster of a given number of cores; clusterEvalQ which evaluates a literal expression on each cluster node. It is a parallel version of evalq. clusterExport which assigns the values on the master R process of the variables named in its named list argument to variables of the same names in the global environment (aka workspace) of each node; parSapply parallel version of sapply.</description>
    </item>
    
    <item>
      <title>System language</title>
      <link>https://choisy.github.io/2018/05/14/system-language/</link>
      <pubDate>Mon, 14 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/2018/05/14/system-language/</guid>
      <description>You can change the language in which R is talking to the user from the definition of the LANG environment variable:
&amp;gt; Sys.getenv(&amp;quot;LANG&amp;quot;) [1] &amp;quot;fr_FR.UTF-8&amp;quot; &amp;gt; log(-3) Warning in log(-3): production de NaN [1] NaN Changing to English:
&amp;gt; Sys.setenv(LANG = &amp;quot;en_US.UTF-8&amp;quot;) &amp;gt; log(-3) Warning in log(-3): NaNs produced [1] NaN and back to French:
&amp;gt; Sys.setenv(LANG = &amp;quot;fr_FR.UTF-8&amp;quot;) &amp;gt; log(-3) Warning in log(-3): production de NaN [1] NaN Or, alternatively:</description>
    </item>
    
    <item>
      <title>Spatial buffers</title>
      <link>https://choisy.github.io/2018/01/22/spatial-buffers/</link>
      <pubDate>Mon, 22 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/2018/01/22/spatial-buffers/</guid>
      <description>Packages needed Install these packages if they are not already installed on your system, then load them:
&amp;gt; library(sp) # plot, points, spsample &amp;gt; library(purrr) # map2 &amp;gt; library(dplyr) # %&amp;gt;%, mutate &amp;gt; library(rgeos) # gIntersection &amp;gt; library(raster) # plot, buffer &amp;gt; library(geosphere) # areaPolygon We can compute statistics in buffer zones around specific points. For that we need spatial data in raster format. These data can be qualitative (e.</description>
    </item>
    
    <item>
      <title>Confidence intervals</title>
      <link>https://choisy.github.io/2018/01/09/confidence-intervals/</link>
      <pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/2018/01/09/confidence-intervals/</guid>
      <description>Simulating fake data:
&amp;gt; x &amp;lt;- 10 * runif(10) &amp;gt; y &amp;lt;- rnorm(10, mean = 2 + 3 * x, 3) Visualizing:
&amp;gt; plot(y ~ x, col = &amp;quot;blue&amp;quot;, pch = 19) Estimating a linear model:
&amp;gt; model &amp;lt;- lm(y ~ x) Calculating and plotting 95 % confidence interval based on simulations:
&amp;gt; xr &amp;lt;- 100 &amp;gt; nb &amp;lt;- 1000 &amp;gt; ci &amp;lt;- .95 &amp;gt; eps &amp;lt;- (1 - ci) / 2 &amp;gt; xs &amp;lt;- seq(min(x), max(x), length = xr) &amp;gt; coef_val &amp;lt;- MASS::mvrnorm(nb, coef(model), vcov(model)) &amp;gt; ys &amp;lt;- t(coef_val %*% rbind(1, xs)) &amp;gt; predconf &amp;lt;- t(apply(ys, 1, quantile, c(eps, 1 - eps))) Let’s plot all this:</description>
    </item>
    
    <item>
      <title>Palettes of colors</title>
      <link>https://choisy.github.io/2018/01/08/palettes-of-colors/</link>
      <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/2018/01/08/palettes-of-colors/</guid>
      <description>A great function to generate palettes of colors is colorRampPalette from the grDevices package. This function takes a set of colors as argument and returns a function similar to grDevices::heat.colors and others that generates a palette of n contiguous colors, n being an argument of this function. The generation of the palette of colors is done by interpolation (spline or linear) and a good starting points for interpolation are the “sequential” and “diverging” palettes generated by RColorBrewer::brewer.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://choisy.github.io/about/</link>
      <pubDate>Thu, 05 May 2016 21:48:51 -0700</pubDate>
      
      <guid>https://choisy.github.io/about/</guid>
      <description>This is a collection of R recipes.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://choisy.github.io/1/01/01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://choisy.github.io/1/01/01/</guid>
      <description>Writing exercises in R /*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */ !function(a,b){&#34;object&#34;==typeof module&amp;&amp;&#34;object&#34;==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(&#34;jQuery requires a window with a document&#34;);return b(a)}:b(a)}(&#34;undefined&#34;!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=&#34;1.11.3&#34;,m=function(a,b){return new m.fn.init(a,b)},n=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,o=/^-ms-/,p=/-([\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:&#34;&#34;,length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0a?b:0);return this.pushStack(c=0&amp;&amp;bc?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(&#34;boolean&#34;==typeof g&amp;&amp;(j=g,g=arguments[h]||{},h++),&#34;object&#34;==typeof g||m.isFunction(g)||(g={}),h===i&amp;&amp;(g=this,h--);ih;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&amp;&amp;(j&amp;&amp;c&amp;&amp;(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&amp;&amp;m.isArray(a)?a:[]):f=a&amp;&amp;m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&amp;&amp;(g[d]=c));return g},m.extend({expando:&#34;jQuery&#34;+(l+Math.random()).replace(/\D/g,&#34;&#34;),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return&#34;function&#34;===m.type(a)},isArray:Array.isArray||function(a){return&#34;array&#34;===m.type(a)},isWindow:function(a){return null!=a&amp;&amp;a==a.window},isNumeric:function(a){return!m.isArray(a)&amp;&amp;a-parseFloat(a)+1=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||&#34;object&#34;!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&amp;&amp;!j.call(a,&#34;constructor&#34;)&amp;&amp;!j.call(a.constructor.prototype,&#34;isPrototypeOf&#34;))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+&#34;&#34;:&#34;object&#34;==typeof a||&#34;</description>
    </item>
    
  </channel>
</rss>